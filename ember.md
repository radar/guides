## Getting Started with EmberJS

*Thanks to Robin Ward who has a lot of great Ember content on [his blog](http://eviltrout.com). Some of his posts, such as [Ember without Ember Data](http://eviltrout.com/2013/03/23/ember-without-data.html) have inspired this guide*.

If at any point you want to see the completed Ember code for this guide, [view the ember branch on blorgh](https://github.com/radar/blorgh/tree/ember)

Ember.js [claims](https://www.youtube.com/watch?v=jScLjUlLTLI) to be the only real JavaScript framework, as apposed to over a thousand other Javascript libraries. The [website for EmberJS](http://emberjs.com) calls Ember "a framework for creating **ambitious** web applications." That's quite a claim to make! Ember is extremely opinionated (just like Rails!), and so a lot of the hard decisions have already been made, which is great.

Rather than go through all the other information about it that you can find out all over the web, let's just go ahead and get started with Ember. What we're going to do is to turn a very, very basic Rails blogging application called "blorgh" into one that uses Ember.

To begin, let's clone "blorgh":

    git clone git@github.com:radar/blorgh
    cd blorgh
    git checkout rails

What this application has at the moment are a `Post` and `Comment` model and if you're at all familiar with the [Getting Started with Rails](http://guides.rubyonrails.org/getting_started.html) guide, then you'll know how these things work.

This application also has an API, which can be accessed at routes like `/api/posts`, `/api/posts/1/comments`. It's this API that we'll be talking to in order to get the information that we need to make Ember happy.

(*In case you're wondering: the API has been on-purpose made to be not directly compatible with Ember Data. I think more APIs than not would fit this category, and therefore a guide showing how to adapt to an API that doesn't fit the conventions, like Spree's API, that Ember Data requires is better than a guide showing you how to use Ember Data. YMMV.*)

## Installing Ember

To install Ember into this application, we'll need to install the `ember-rails` and `ember-source` gems, which we can do by adding these lines to our `Gemfile`:

    gem 'ember-rails'
    gem 'ember-source', '1.4.0'

Then we can run `bundle install` to install these gems.

Next, we need to set up the Ember structure for this application, which we can do with this command:

    rails generate ember:bootstrap

This creates a couple of sub-directories within `app/assets/javascripts`:

* `models`: These are the objects which will talk with our API to retrieve data from it.
* `controllers`: Used for decorating the models with display logic. Similar concept to helpers within Rails.
* `views`: A place to put complicated view logic.
* `components`: Reusable pieces of the application.
* `routes`: Code that tells Ember what to do when a specific route is requested.
* `templates`: Handlebar templates which are responsible for displaying the information from the models.
* `helpers`: A place to define Handlebar helpers for your templates.

You'll see how all these pieces tie together throughout this tutorial, so don't worry if you don't grok it just yet.

## Surveying the landscape

If we look at our `app/assets/javascripts` directory now, we'll have two versions of `application.js`, one called `application.js` and one called `application.js.coffee`. The latter was generated by `ember:bootstrap`, and is the one we'll keep around. Let's delete `app/assets/javascripts/application.js` and look at `app/assets/javascripts/application.js.coffee`.

```coffee
#= require handlebars
#= require ember
#= require ember-data
#= require_self
#= require blorgh

# for more details see: http://emberjs.com/guides/application/
window.Blorgh = Ember.Application.create()
```

This file requires *almost* everything that we need for Ember. It's actually missing a require for jquery, which we can just simply add at the top. In this guide I'm not going to use Ember Data because the API that the application provides does not comply with Ember Data's standards, so we will remove that line. The end result will be a file that looks like:

```coffee
#= require jquery
#= require handlebars
#= require ember
#= require_self
#= require blorgh

# for more details see: http://emberjs.com/guides/application/
window.Blorgh = Ember.Application.create()
```

This file now requires jQuery, Handlebars, Ember, itself and then finally `blorgh`. The `blorgh` file that it's pointing at is `app/assets/javascripts/blorgh.js` which contains this:

```coffee
#= require_tree ./models
#= require_tree ./controllers
#= require_tree ./views
#= require_tree ./helpers
#= require_tree ./components
#= require_tree ./templates
#= require_tree ./routes
#= require ./router
#= require_self
```

The `store` file here will set up an Ember Data store, but since we're not going to be using that we can remove that line. The rest of the file includes all the other parts of our application: the models, controllers, views, helpers, components, templates, routes and the all-important router. The router is what's going to tell our Ember app what to do, extremely similar to what `config/routes.rb` does in Rails apps.

## Starting our Ember app

We're going to host our Ember app *through* our Rails app. The Rails application is going to be providing the API that Ember will use to perform CRUD actions on our data. In this tutorial, we're going to replace all the Rails code that is currently responsible for displaying posts and comments, with some Ember code that does the same thing.

Let's ensure that the database is setup now by running `rake db:setup`. After that, we will start the Rails app with `rails s`. When we go to http://localhost:3000 we should see the application with a couple of posts.

![Posts](/ember/posts.png)

At this point, our Ember code should be up and running as well. We can see if that's true by opening the JavaScript console for our browser. If you're using Chrome, you'll see something like this:

![Chrome Console](/ember/chrome_console.png)

This is some helpful information that tells us the application is running. If you've installed the [Ember Inspector](https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi?hl=en) within Chrome, you can go over to that tab in the JavaScript console and see an indication that our app is running too:

![Chrome Ember Inspector](/ember/chrome_ember_inspector.png)

If the application wasn't running, you'd see this:

![Ember Not Found](/ember/ember_application_not_found.png)

If you *are* seeing this, then make sure you've required the correct JavaScript files.

If you *aren't* seeing this, then you've correctly setup the Ember app and we can proceed.

The first thing we're going to do is to provide an outlet for Ember to put its content. This is achieved by providing an `application` template in `app/assets/javascripts/templates/application.hbs`:

```hbs
<h1>My blog</h1>
<p>Read all about it!</p>
{{outlet}}
```

With this template now defined, we can clear out everything within the `body` tag within `app/views/layouts/application.html.erb` leaving just this:

```erb
<!DOCTYPE html>
<html>
<head>
  <title>Blorgh</title>
  <%= stylesheet_link_tag    "application", media: "all" %>
  <%= javascript_include_tag "application" %>
  <%= csrf_meta_tags %>
</head>
<body>
</body>
</html>
```

Ember will now be responsible for rendering everything within our application.

This new template defines the application template for Ember. Ember will be rendering all of its content into this area. By default, Ember will put this template within the `body` tag of our application. If we didn't want it there, we can set the `rootElement` option for our application:

```coffee
window.Blorgh = Ember.Application.create(
  rootElement: '#someOtherContainer'
)
```

For now, we'll leave it with the default behaviour of putting it within the `body` tag.

So what's the next step after this? Well, Ember doesn't really provide any
hints itself. However, there's some debug settings that we can set that will
give us some hints as to what to do. These are mentioned in the [Understanding Ember: Debugging](http://emberjs.com/guides/understanding-ember/debugging/) guide, but I'll repeat them here because why not.

Let's open `app/assets/javascripts/application.js.coffee` and set the `LOG_TRANSITIONS`, `LOG_TRANSITIONS_INTERNAL`, `LOG_VIEW_LOOKUPS` settings:

```cofeee
window.Blorgh = Ember.Application.create
  LOG_TRANSITIONS: true
  LOG_TRANSITIONS_INTERNAL: true
  LOG_VIEW_LOOKUPS: true
```

These will show us a lot more information in our console, which will tell us what Ember's doing during a request.

(*Future versions of Ember will also have a `LOG_RESOLVER` option, which gives us even more information. My [issue](https://github.com/emberjs/ember.js/issues/4654) posted about that resulted in [a PR](https://github.com/emberjs/ember.js/issues/4655) to add this option in. This option is extremely useful for tracking down the correct names of things in more complicated apps.*)

If we refresh the page now, we'll see this on our console:

![Ember Transitions](/ember/ember_transitions.png)

## Rendering a template

On the page itself, it will now be blank. This is because we're not telling Ember to do anything. Where we are now -- on the homepage -- we want to show a list of posts. If we look at the transitions in our console, we can see that Ember cannot find the index template:

```
Could not find "index" template or view. Nothing will be rendered
```

Ember's attempted to find this template, but couldn't find it. We can define this template within `app/assets/javascripts/templates/index.hbs`. Let's start off simple:

```hbs
<h1>Posts</h1>
```

When we refresh that page, we should see that header now appearing:

![Posts header](/ember/posts_header.png)

This is our first Ember view rendering. That was easy!

## Fetching content

Our next couple of steps is to find the posts and add them to this page. In Ember, this is done by objects that extend from `Ember.Route`. We don't need to create these objects ourselves -- as we would have to do in other frameworks, like Backbone -- Ember will automatically create them itself. We can see the result of this magic when we switch to the "Routes" tab in the Ember Inspector in Chrome:

![Ember Routes](/ember/ember_routes.png)

Therefore we can know from this information that we need to define the fetching of the data within the `IndexRoute` object. Let's create a new file at `app/assets/javascripts/routes/index.js.coffee`:

```coffee
Blorgh.IndexRoute = Ember.Route.extend
  model: ->
    Blorgh.Post.findAll()
```

This `IndexRoute` object is responsible for the collection of data. This is similar in concept to an action within a Rails controller. This data fetching is done with the `Blorgh.Post.findAll()` function call. If we refresh our page at this point, we'll see that our Ember code is no longer happy:

```
Error while loading route: TypeError: Cannot call method 'findAll' of undefined
```

While Ember infers routes, it does not infer models. Therefore we must define the model ourselves, which we can do by creating a new file in `app/assets/javascripts/models/post.js.coffee`:

```coffee
Blorgh.Post = Ember.Object.extend({})
```

This method defines a very basic Ember class that acts as a base for all of our Post object methods, (eventually) including `findAll`. At this point if we refresh the page, we'll see this error:

```
var m = meta(this), proto = m...<omitted>... } has no method 'findAll'
```

This error is happening because we've defined `Blorgh.Post`, but haven't defined the `findAll` method. We need to define the `findAll` function on `Blorgh.Post` so that `Blorgh.IndexRoute` can happily collect its data. It's going to act very similar to a class method within a Ruby class, and so to do that, we need to call `reopenClass` and define our function:

```coffee
Blorgh.Post = Ember.Object.extend({})

Blorgh.Post.reopenClass
  findAll: ->
    posts = Em.A()
    $.getJSON('/api/posts').then (data) ->
      $.each data.posts, (post) ->
        posts.pushObject(data)
    posts
```

This code defines a simple Ember.Array object, which is the type of object that needs to be returned with the `model` call in `Blorgh.IndexRoute`. After defining that array, the code then makes a request to `/api/posts` which will query our API. Our API will dutifully return all the posts, and then the rest of the code in this function iterates through all of those posts and adds them to array. The final line in the method returns the list of posts.

When we refresh the page, we'll no longer see an error. Instead, at the very bottom of the console output, we'll see this:

```
XHR finished loading: "http://localhost:3000/api/posts".
```

This is a great indicator that shows that our Ember app is making a request to fetch all the posts. With all the posts being fetched, the next step is to display them. We can take care of this within the index template, over at `app/assets/javascripts/templates/index.hbs`:

```hbs
<h1>Posts</h1>

{{#each}}
  <h2>{{title}}</h2>
  {{text}}
{{/each}}
```

In this new code, we're iterating through the array returned by `Blorgh.IndexRoute`'s `model` function using the `{{#each}}` helper provided by Handlebars. This automatically knows what we want to iterate over, and it just does it. Within the scope of the `each` "block", we can reference the attributes of the posts very directly.

When we refresh this page, we'll see the posts now displaying with the power of Ember:

![Ember Posts](/ember/ember_posts.png)

## Retrospective #1: Posts displaying

Our code is so far pretty simple. We've got an Ember application defined within `app/assets/application.js.coffee`, a model within `app/assets/models/post.js.coffee`, a route within `app/assets/routes/index.js.coffee` and a template at `app/assets/templates/index.js.coffee`. Ember is automatically routing to the index route, which is handled with `Blorgh.IndexRoute`. `Blorgh.IndexRoute` collects the information it needs from `Blorgh.Post.findall()`, and finally displays that within the one and only template in our application.

## Viewing a single post

While it's all fine and dandy that we can see a list of posts, sometimes we just want to hone-in on a single post. Let's work on adding this feature to our application as our next step.

The first part of this will be to turn the post's title into a link which will take us to the page that will show a single blog post. We can do this using the `link-to` helper that Ember provides:

```hbs
<h1>Posts</h1>

{{#each}}
  <h2>{{#link-to 'post' this}}{{title}}{{/link-to}}</h2>
  {{text}}
{{/each}}
```

If we refresh the page now, it will show nothing on the page because Ember's now showing an error:

```
Uncaught Error: Assertion Failed:
  The attempt to link-to route 'post' failed (also tried 'posts.show.index').
  The router did not find 'posts.show' in its possible routes:
  'loading',
  'error',
  'index'
```

Ember is complaining here that there is no route for `posts.show`, which is true. Ember creates the `index`, `error` and `loading` routes itself, but will not assume any routes past that.

We can define this route in `app/assets/javascripts/router.js.coffee` by using this code:

```
Blorgh.Router.map ()->
  @resource 'post', path: '/posts/:post_id'
```

The `resource` function defines a new route for our Ember app. When we refresh our app again, we will now be able to click on a post's link and go to that post's page. That doesn't currently display anything and the console again will tell us why:

```
Could not find "post" template or view. Nothing will be rendered Object {fullName: "template:post"}
```

Let's create this new template within `app/assets/templates/post.hbs`:

```coffee
<h2>{{title}}</h2>
{{text}}
```

When we refresh this page, we'll again see nothing on the page. This is because there's another error in our code, and one that maybe we wouldn't expect:

```
var m = meta(this), proto = m...<omitted>... } has no method 'find'
```

We saw an error just like this when we were implementing our `findAll` function for the `Blorgh.Post` model. What Ember has done here is that it's assumed that we want to use the `Blorgh.Post` model just based on the name of the resource that we defined in `router.js.coffee`. It has assumed correctly, and so we should define this new function within `app/assets/javascripts/models/post.js.coffee`

```coffee
Blorgh.Post.reopenClass
  find: (id) ->
    $.getJSON("/api/posts/#{id}").then (post) ->
      post
```

Refreshing the page will now show us just the one post.

![Ember Post](/ember/ember_post.png)

We haven't needed to define a `Blorgh.PostRoute` object for this route because Ember has done that for us, and *better still* it's assumed that we want the `model` function in that to do a `find` call on `Blorgh.Post`. That's pretty cool.

Let's make the "My Blog" link within the application template link back to the homepage so we can quickly switch between these two pages.

```hbs
<h1>{{#link-to 'index'}}My blog{{/link-to}}</h1>
<p>Read all about it!</p>
{{outlet}}
```

Let's refresh the page and make sure this link works. It should show the list of posts again:

![Ember Posts](/ember/ember_posts.png)

We now have two of the normal seven actions down: showing a list of a resource and showing an individual item from that resource.

## Creating a new post

Let's work on adding another two actions: showing a form to create a new post and actually creating that new post.

To begin with, we're going to need a link to create a new post on our listing of posts, which we can do using another `link-to` inside of `app/assets/templates/index.hbs`:

```hbs
<h1>Posts</h1>

{{#link-to 'posts.new'}}New Post{{/link-to}}
{{#each}}
  <h2>{{#link-to 'post' this}}{{title}}{{/link-to}}</h2>
  {{text}}
{{/each}}
```

We're using a new route here called `posts.new`. Just like with the `post` route, we will need to define this in `app/assets/router.js.coffee`

Blorgh.Router.map ()->
  @resource 'post', path: '/posts/:post_id'
  @resource 'posts.new', path:'/post/new'

For this route to do anything, we will need to create a template at `app/assets/javascripts/templates/posts/new.hbs`:

```hbs
<h2>New Post</h2>
<form>
  <p class='input-group'>
    <label for='title'>Title</label><br>
    {{input value=title class="form-control input-lg" size="50"}}
  </p>
  <p class='input-group'>
    <label for='text'>Text</label><br>
    {{textarea value=text class="form-control input-lg" size="50" rows="10" cols="100"}}
  </p>
  <input type='button' value='Save Post' class='btn btn-primary' {{action 'save' this}}>
</form>
```

In this template we're using a couple of Ember's helpers to display the fields for the form; `input` and `textarea`. At the bottom we're using `action` which will add an onClick event to the 'Save Post' button in our form and will trigger the `save` action.

Actions in Ember are, just like in Rails, defined within controllers. The controller for this template is being automatically inferred by Ember to be `Blorgh.PostsNewController`, but we now want to define some custom actions on it. Therefore we will define this controller for ourselves at `app/assets/javascripts/controllers/posts/new.js.coffee`.

```coffee
Blorgh.PostsNewController = Ember.ObjectController.extend
  content: Blorgh.Post.create({})

  actions:
    save: ->
      this.content.save()
```

In the controller, we set up some `content` for the template. When we go to save the information from our form in the `save` action, the `content` object will have the values from the form automatically.

Defining the `save` action in this controller is as simple as defining it within the `actions` of the controller as a new function which simply calls `save` on the `Blorgh.Post` object that our form works with.

If we refresh this page and attempt to create a new post, we'll see this error:

```
Uncaught TypeError: Object [object Object] has no method 'save'
```

This is happening because our `Blorgh.Post` model does not have this method. Let's add that now in `app/assets:

```coffee
Blorgh.Post = Ember.Object.extend
  save: ->
    $.post "api/posts",
      post: {
        title: this.title
        text: this.text
      }
```

We're adding this method inside of extend because we're now working on a single object of `Blorgh.Post` instead of the class. The functions defined within `reopenClass` are non-specific to an object.
