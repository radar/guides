## Getting Started with EmberJS

*Thanks to Robin Ward who has a lot of great Ember content on [his blog](http://eviltrout.com). Some of his posts, such as [Ember without Ember Data](http://eviltrout.com/2013/03/23/ember-without-data.html) have inspired this guide*.

*Also thanks to Rob Yurkowski, Ivan Vanderbyl and Miles Starkenburg for some early-on proof-reading*


If at any point you want to see the completed Ember code for this guide, [view the ember branch on blorgh](https://github.com/radar/blorgh/tree/ember)

Ember.js [claims](https://www.youtube.com/watch?v=jScLjUlLTLI) to be the only real JavaScript framework, as opposed to over a thousand other Javascript libraries. The [website for EmberJS](http://emberjs.com) calls Ember "a framework for creating **ambitious** web applications." That's quite a claim to make! Ember is extremely opinionated (just like Rails!), and so a lot of the hard decisions have already been made, which is great.

Rather than go through all the other information about it that you can find out all over the web, let's just go ahead and get started with Ember. What we're going to do is to turn a very, very basic Rails blogging application called "blorgh" into one that uses Ember.

To begin, let's clone "blorgh":

    git clone git@github.com:radar/blorgh
    cd blorgh
    git checkout rails

What this application has at the moment are a `Post` and `Comment` model and if you're at all familiar with the [Getting Started with Rails](http://guides.rubyonrails.org/getting_started.html) guide, then you'll know how these things work.

This application also has an API, which can be accessed at routes like `/api/posts`, `/api/posts/1/comments`. It's this API that we'll be talking to in order to get the information that we need to make Ember happy.

(*In case you're wondering: the API has been on-purpose made to be not directly compatible with the `RESTAdapter` provided by Ember Data. While it is possible to build your own Adapter, I personally think it's better if you learn the structure of an Ember app first, then apply an Ember Data adapter retrospectively. That's what I'll be doing in this guide after we build the post resource actions.*)

## Installing Ember

To install Ember into this application, we'll need to install the `ember-rails` and `ember-source` gems, which we can do by adding these lines to our `Gemfile`:

```ruby
gem 'ember-rails'
gem 'ember-source', '1.4.0'
```

Then we can run `bundle install` to install these gems.

Next, we need to set up the Ember structure for this application, which we can do with this command:

    rails generate ember:bootstrap

This creates a couple of sub-directories within `app/assets/javascripts`:

* `models`: These are the objects which will talk with our API to retrieve data from it.
* `controllers`: Used for decorating the models with display logic. Similar concept to decorators within Rails.
* `views`: A place to put complicated view logic.
* `components`: Reusable pieces of the application.
* `routes`: Code that tells Ember what to do when a specific route is requested.
* `templates`: Handlebars templates which are responsible for displaying the information from the models.
* `helpers`: A place to define Handlebars helpers for your templates.

You'll see how all these pieces tie together throughout this tutorial, so don't worry if you don't grok it just yet.

## Surveying the landscape

If we look at our `app/assets/javascripts` directory now, we'll have two versions of `application.js`, one called `application.js` and one called `application.js.coffee`. The latter was generated by `ember:bootstrap`, and is the one we'll keep around. Let's delete `app/assets/javascripts/application.js` and look at `app/assets/javascripts/application.js.coffee`.

```coffee
#= require handlebars
#= require ember
#= require ember-data
#= require_self
#= require blorgh

# for more details see: http://emberjs.com/guides/application/
window.Blorgh = Ember.Application.create()
```

This file requires *almost* everything that we need for Ember. It's actually missing a require for jquery and jquery_ujs, which we can just simply add at the top.

*In this guide I'm not going to use Ember Data because the API that the application provides does not comply with Ember Data's standards, and because of that, implementing a proper Ember Data interface is tough. A later section of this guide will cover how to do that. For now, let's just grasp the initial Ember concepts.*

The end result will be a file that looks like:

```coffee
#= require jquery
#= require jquery_ujs
#= require handlebars
#= require ember
#= require_self
#= require blorgh

# for more details see: http://emberjs.com/guides/application/
window.Blorgh = Ember.Application.create()
```

This file now requires jQuery, Handlebars, Ember, itself and then finally `blorgh`. The `blorgh` file that it's pointing at is `app/assets/javascripts/blorgh.js` which contains this:

```coffee
#= require_tree ./models
#= require_tree ./controllers
#= require_tree ./views
#= require_tree ./helpers
#= require_tree ./components
#= require_tree ./templates
#= require_tree ./routes
#= require ./router
#= require_self
```

The `store` file here will set up an Ember Data store, but since we're not going to be using that we can remove that line. The rest of the file includes all the other parts of our application: the models, controllers, views, helpers, components, templates, routes and the all-important router. The router is what's going to tell our Ember app what to do, extremely similar to what `config/routes.rb` does in Rails apps.

## Starting our Ember app

We're going to host our Ember app *through* our Rails app. The Rails application is going to be providing the API that Ember will use to perform CRUD actions on our data. In this tutorial, we're going to replace all the Rails code that is currently responsible for displaying posts and comments, with some Ember code that does the same thing.

Let's ensure that the database is setup now by running `rake db:setup`. After that, we will start the Rails app with `rails s`. When we go to http://localhost:3000 we should see the application with a couple of posts.

![Posts](/ember/posts.png)

At this point, our Ember code should be up and running as well. We can see if that's true by opening the JavaScript console for our browser. If you're using Chrome, you'll see something like this:

![Chrome Console](/ember/chrome_console.png)

This is some helpful information that tells us the application is running. If you've installed the [Ember Inspector](https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi?hl=en) within Chrome, you can go over to that tab in the JavaScript console and see an indication that our app is running too:

![Chrome Ember Inspector](/ember/chrome_ember_inspector.png)

If the application wasn't running, you'd see this:

![Ember Not Found](/ember/ember_application_not_found.png)

If you *are* seeing this, then make sure you've required the correct JavaScript files.

If you *aren't* seeing this, then you've correctly setup the Ember app and we can proceed.

The first thing we're going to do is to provide an outlet for Ember to put its content. This is achieved by providing an `application` template in `app/assets/javascripts/templates/application.hbs`:

```hbs
<h1>My blog</h1>
<p>Read all about it!</p>
{{outlet}}
```

With this template now defined, we can clear out everything within the `body` tag within `app/views/layouts/application.html.erb` leaving just this:

```erb
<!DOCTYPE html>
<html>
<head>
  <title>Blorgh</title>
  <%= stylesheet_link_tag    "application", media: "all" %>
  <%= javascript_include_tag "application" %>
  <%= csrf_meta_tags %>
</head>
<body>
</body>
</html>
```

Ember will now be responsible for rendering everything within our application.

This new template defines the application template for Ember. Ember will be rendering all of its content into this area. By default, Ember will put this template within the `body` tag of our application. If we didn't want it there, we can set the `rootElement` option for our application:

```coffee
window.Blorgh = Ember.Application.create(
  rootElement: '#someOtherContainer'
)
```

For now, we'll leave it with the default behaviour of putting it within the `body` tag.

So what's the next step after this? Well, Ember doesn't really provide any
hints itself. However, there's some debug settings that we can set that will
give us some hints as to what to do. These are mentioned in the [Understanding Ember: Debugging](http://emberjs.com/guides/understanding-ember/debugging/) guide, but I'll repeat them here because why not.

Let's open `app/assets/javascripts/application.js.coffee` and set the `LOG_TRANSITIONS`, `LOG_TRANSITIONS_INTERNAL`, `LOG_VIEW_LOOKUPS` settings:

```coffee
window.Blorgh = Ember.Application.create
  LOG_TRANSITIONS: true
  LOG_TRANSITIONS_INTERNAL: true
  LOG_VIEW_LOOKUPS: true
```

These will show us a lot more information in our console, which will tell us what Ember's doing during a request.

(*Future versions of Ember will also have a `LOG_RESOLVER` option, which gives us even more information. My [issue](https://github.com/emberjs/ember.js/issues/4654) posted about that resulted in [a PR](https://github.com/emberjs/ember.js/issues/4655) to add this option in. This option is extremely useful for tracking down the correct names of things in more complicated apps.*)

If we refresh the page now, we'll see this on our console:

![Ember Transitions](/ember/ember_transitions.png)

## Rendering a template

On the page itself, it will now be blank. This is because we're not telling Ember to do anything. Where we are now -- on the homepage -- we want to show a list of posts. If we look at the transitions in our console, we can see that Ember cannot find the index template:

```
Could not find "index" template or view. Nothing will be rendered
```

Ember's attempted to find this template, but couldn't find it. We can define this template within `app/assets/javascripts/templates/index.hbs`. Let's start off simple:

```hbs
<h1>Posts</h1>
```

When we refresh that page, we should see that header now appearing:

![Posts header](/ember/posts_header.png)

This is our first Ember view rendering. That was easy!

## Fetching content

Our next couple of steps is to find the posts and add them to this page. In Ember, this is done by objects that extend from `Ember.Route`. We don't need to create these objects ourselves -- as we would have to do in other frameworks, like Backbone -- Ember will automatically create them itself. We can see the result of this magic when we switch to the "Routes" tab in the Ember Inspector in Chrome:

![Ember Routes](/ember/ember_routes.png)

Therefore we can know from this information that we need to define the fetching of the data within the `IndexRoute` object. Let's create a new file at `app/assets/javascripts/routes/index.js.coffee`:

```coffee
Blorgh.IndexRoute = Ember.Route.extend
  model: ->
    Blorgh.Post.findAll()
```

This `IndexRoute` object is responsible for the collection of data. This is similar in concept to an action within a Rails controller. This data fetching is done with the `Blorgh.Post.findAll()` function call. If we refresh our page at this point, we'll see that our Ember code is no longer happy:

```
Error while loading route: TypeError: Cannot call method 'findAll' of undefined
```

While Ember infers routes, it does not infer models. Therefore we must define the model ourselves, which we can do by creating a new file in `app/assets/javascripts/models/post.js.coffee`:

```coffee
Blorgh.Post = Ember.Object.extend({})
```

This method defines a very basic Ember class that acts as a base for all of our Post object methods, (eventually) including `findAll`. At this point if we refresh the page, we'll see this error:

```
var m = meta(this), proto = m...<omitted>... } has no method 'findAll'
```

This error is happening because we've defined `Blorgh.Post`, but haven't defined the `findAll` method. We need to define the `findAll` function on `Blorgh.Post` so that `Blorgh.IndexRoute` can happily collect its data. It's going to act very similar to a class method within a Ruby class, and so to do that, we need to call `reopenClass` and define our function:

```coffee
Blorgh.Post = Ember.Object.extend({})

Blorgh.Post.reopenClass
  findAll: ->
    posts = Em.A()
    $.getJSON('/api/posts').then (data) ->
      Ember.run () ->
        posts.pushObjects(data.posts)
        posts
```

This code defines a simple Ember.Array object, which is the type of object that needs to be returned with the `model` call in `Blorgh.IndexRoute`. After defining that array, the code then makes a request to `/api/posts` using `$.getJSON`.


which will query our API for the posts and our API will dutifully return all the posts. Once that's done, we call `Ember.run`.

`Ember.run` is fairly interesting. What this will do is will define a function to be run within the next run-loop. If we were creating 5 posts by making 5 async requests to `/api/posts`, this would *normally* require 5 re-draws of the page. By using `Ember.run`, we queue up all of these and the next time Ember's run loop happens, all 5 elements will be redrawn at the same time.

When we refresh the page, we'll no longer see an error. Instead, at the very bottom of the console output, we'll see this:

```
XHR finished loading: "http://localhost:3000/api/posts".
```

This is a great indicator that shows that our Ember app is making a request to fetch all the posts. With all the posts being fetched, the next step is to display them. We can take care of this within the index template, over at `app/assets/javascripts/templates/index.hbs`:

```hbs
<h1>Posts</h1>

{{#each}}
  <h2>{{title}}</h2>
  {{text}}
{{/each}}
```

In this new code, we're iterating through the array returned by `Blorgh.IndexRoute`'s `model` function using the `{{#each}}` helper provided by Handlebars. This automatically knows what we want to iterate over, and it just does it. Within the scope of the `each` "block", we can reference the attributes of the posts very directly.

When we refresh this page, we'll see the posts now displaying with the power of Ember:

![Ember Posts](/ember/ember_posts.png)

## Retrospective #1: Posts displaying

Our code is so far pretty simple. We've got an Ember application defined within `app/assets/application.js.coffee`, a model within `app/assets/models/post.js.coffee`, a route within `app/assets/routes/index.js.coffee` and a template at `app/assets/javscripts/templates/index.js.coffee`. Ember is automatically routing to the index route, which is handled with `Blorgh.IndexRoute`. `Blorgh.IndexRoute` collects the information it needs from `Blorgh.Post.findAll()`, and finally displays that within the one and only template in our application.

## Viewing a single post

While it's all fine and dandy that we can see a list of posts, sometimes we just want to hone-in on a single post. Let's work on adding this feature to our application as our next step.

The first part of this will be to turn the post's title into a link which will take us to the page that will show a single blog post. We can do this using the `link-to` helper that Ember provides:

```hbs
<h1>Posts</h1>

{{#each}}
  <h2>{{#link-to 'post' this}}{{title}}{{/link-to}}</h2>
  {{text}}
{{/each}}
```

If we refresh the page now, it will show nothing on the page because Ember's now showing an error:

```
Uncaught Error: Assertion Failed:
  The attempt to link-to route 'post' failed (also tried 'posts.show.index').
  The router did not find 'posts.show' in its possible routes:
  'loading',
  'error',
  'index'
```

Ember is complaining here that there is no route for `posts.show`, which is true. Ember creates the `index`, `error` and `loading` routes itself, but will not assume any routes past that.

We can define this route in `app/assets/javascripts/router.js.coffee` by using this code:

```coffee
Blorgh.Router.map ()->
  @resource 'post', path: '/posts/:post_id'
```

The `resource` function defines a new route for our Ember app. We're using `:post_id` (instead of `:id`) here as Ember will infer from that that we want to load from the `Post` model in our app.

When we refresh our app again, we will now be able to click on a post's link and go to that post's page. That doesn't currently display anything and the console again will tell us why:

```
Could not find "post" template or view. Nothing will be rendered Object {fullName: "template:post"}
```

Let's create this new template within `app/assets/javascripts/templates/post.hbs`:

```hbs
<h2>{{title}}</h2>
{{text}}
```

When we refresh this page, we'll again see nothing on the page. This is because there's another error in our code, and one that maybe we wouldn't expect:

```
var m = meta(this), proto = m...<omitted>... } has no method 'find'
```

We saw an error just like this when we were implementing our `findAll` function for the `Blorgh.Post` model. What Ember has done here is that it's assumed that we want to use the `Blorgh.Post` model just based on the name of the resource that we defined in `router.js.coffee`. It has assumed correctly, and so we should define this new function within `app/assets/javascripts/models/post.js.coffee`

```coffee
Blorgh.Post.reopenClass
  find: (id) ->
    $.getJSON("/api/posts/#{id}").then (post) ->
      Ember.run () ->
        Blorgh.Post.create(post)
```

Refreshing the page will now show us just the one post.

![Ember Post](/ember/ember_post.png)

We haven't needed to define a `Blorgh.PostRoute` object for this route because Ember has done that for us, and *better still* it's assumed that we want the `model` function in that to do a `find` call on `Blorgh.Post`. That's pretty cool.

Let's make the "My Blog" link within the application template link back to the homepage so we can quickly switch between these two pages.

```hbs
<h1>{{#link-to 'index'}}My blog{{/link-to}}</h1>
<p>Read all about it!</p>
{{outlet}}
```

Let's refresh the page and make sure this link works. It should show the list of posts again:

![Ember Posts](/ember/ember_posts.png)

We now have two of the normal seven actions down: showing a list of a resource and showing an individual item from that resource.

## Creating a new post

Let's work on adding another two actions: showing a form to create a new post and actually creating that new post.

To begin with, we're going to need a link to create a new post on our listing of posts, which we can do using another `link-to` inside of `app/assets/javscripts/templates/index.hbs`:

```hbs
<h1>Posts</h1>

{{#link-to 'posts.new'}}New Post{{/link-to}}
{{#each}}
  <h2>{{#link-to 'post' this}}{{title}}{{/link-to}}</h2>
  {{text}}
{{/each}}
```

We're using a new route here called `posts.new`. Just like with the `post` route, we will need to define this in `app/assets/router.js.coffee`

```coffee
Blorgh.Router.map ()->
  @resource 'post', path: '/posts/:post_id'
  @resource 'posts.new', path: '/posts/new'
```

For this route to do anything, we will need to create a template at `app/assets/javascripts/templates/posts/new.hbs`:

```hbs
<h2>New Post</h2>
<form>
  <p class='input-group'>
    <label for='title'>Title</label><br>
    {{input value=title class="form-control input-lg" size="50"}}
  </p>
  <p class='input-group'>
    <label for='text'>Text</label><br>
    {{textarea value=text class="form-control input-lg" size="50" rows="10" cols="100"}}
  </p>
  <input type='button' value='Save Post' class='btn btn-primary' {{action 'save' this}}>
</form>
```

In this template we're using a couple of Ember's helpers to display the fields for the form: `input` and `textarea`. At the bottom we're using `action` which will add an onClick event to the 'Save Post' button in our form and will trigger the `save` action.

The `input` and `textarea` fields here do not have `title` and `text` quoted because we want these to be bound to the model for this route. This binding will mean that when we perform the `save` action, our code will already know about these parameters.

Actions in Ember are defined within the corresponding routes. The route for this template is being automatically inferred by Ember to be `Blorgh.PostsNewRoute`, but we now want to define some custom actions on it. Therefore we will define this route for ourselves at `app/assets/javascripts/routes/posts/new.js.coffee`.

```coffee
Blorgh.PostsNewRoute = Ember.Route.extend
  model: ->
    Blorgh.Post.create({})

  actions:
    save: ->
      route = this
      this.currentModel.save().then (model) ->
        route.transitionToRoute('post', model)
```

In the route, we give it a `model` for the template. When we go to save the information from our form in the `save` action, the `model` object will have the values from the form automatically thanks to Ember's automatic binding.

Defining the `save` action in this route is as simple as defining it within the `actions` of the routes as a new function which calls `save` on the `Blorgh.Post` model that our form works with. When the save is successful, we transition to the `post` route with our new model.

If we refresh this page and attempt to create a new post, we'll see this error:

```
Uncaught TypeError: Object [object Object] has no method 'save'
```

This is happening because our `Blorgh.Post` model does not have this method. Let's add that now in `app/assets`:

```coffee
Blorgh.Post = Ember.Object.extend
  save: ->
    $.post "api/posts",
      post:
        title: this.title
        text: this.text
    .then (response) ->
      Ember.run () ->
        Blorgh.Post.create(response)
```

We're adding this function inside of `extend` because we're now working on a single object of `Blorgh.Post` instead of the class. The functions defined within `reopenClass` are non-specific to an object.

The `save` function makes a `POST` request to `/api/posts` and sends through the information from the model. The `.then` call at the end determines what to do in case of a *successful* request, and all we want is to return a new `Blorgh.Post` object based on the response back from the server. This object will be passed back to our route, which will then transition to the right post.

Let's see if this works now by refreshing the page and entering something into the title and text fields, then submitting the form. We should see that post's information come up on the screen immediately:

![New Ember Post](/ember/ember_new_post.png)

## Editing a post

Now that we've got the `index`, `show`, `new` and `create` parts of the `post` resource complete, the next step is to add the ability to edit an existing post. Lucky for us, most of the pieces that we need are already in place: we have a model that will find the post and a form that we can re-use. There's not much else that we need to add other than an 'Edit' link somewhere.

The appropriate somewhere would be in the post template, at `app/assets/javascripts/templates/post.hbs`:

```hbs
<h2>{{title}}</h2>
<div>
  {{#link-to 'posts.edit' this}}Edit{{/link-to}}
</div>
{{text}}
```

This `link-to` is using a new route called `posts.edit`, which we should now define within `app/assets/javascripts/router.js`

```coffee
Blorgh.Router.map ()->
  @resource 'post', path: '/posts/:post_id'
  @resource 'posts.new', path:'/posts/new'
  @resource 'posts.edit', path: '/posts/:post_id/edit'
```

After defining the route, the next step is to create a template which we can do in `app/assets/javascripts/templates/posts/edit.hbs`.

```hbs
<h2>Editing Post {{title}}</h2>
{{ partial 'posts/form' }}
```

Within this template, we're using another Ember helper: `partial`. This will render a Handlebars template in that place, just like partial rendering works within Rails. Let's create this partial by taking out most of the content in `app/assets/javascripts/templates/posts/new.hbs` and turning it into this:

```hbs
<h2>New Post</h2>
{{ partial 'posts/form' }}
```

To define the partial, we need to create a new template at `app/assets/javascripts/templates/posts/_form.hbs`:

```hbs
<form>
  <p class='input-group'>
    <label for='title'>Title</label><br>
    {{input value=title class="form-control input-lg" size="50"}}
  </p>
  <p class='input-group'>
    <label for='text'>Text</label><br>
    {{textarea value=text class="form-control input-lg" size="50" rows="10" cols="100"}}
  </p>
  <input type='button' value='Save Post' class='btn btn-primary' {{action 'save' this}}>
</form>
```

This partial template will now be used by both the new form and the edit form.

Let's refresh the page and click "Edit" for that post that we just created. We should see be on the edit route now, but the form is blank, which is no good!

![Ember Blank Edit Post](/ember/ember_blank_edit_post.png)

This is happening because we have not told the route what model to load. Let's define this route now within `app/assets/javascripts/routes/posts/edit.js.coffee`:

```coffee
Blorgh.PostsEditRoute = Ember.Route.extend
  actions:
    save: ->
      route = this
      this.currentModel.save().then (model) ->
        route.transitionTo('post', model)
```

Unlike the `PostsNewRoute`, we don't need to define a `model` function here. The reason for that is because Ember will infer that we want to look up on the `Post` route automatically because our route is defined as `/posts/:post_id/edit`, with the `:post_id` part being how the inferrence is happening.

The `save` action in this route is the same as it was in `PostsNewRoute`, we just call `save()` on the current model and transition back to the post route.

We're going to need to edit the `save` function from `Blorgh.Post` to act differently when the object that it's working on has an `id`. If we attempt to save this form now, it will just create another post with the title and text from the form. Let's fix this up now:

```coffee
save: ->
  if this.id
    @update()
  else
    @create()

update: ->
  $.ajax "api/posts/#{@id}",
    type: 'PUT',
    data:
      post:
        title: this.title
        text: this.text
  .then (response) ->
    Ember.run () ->
      Blorgh.Post.create(response)

create: ->
  $.post "api/posts",
    post:
      title: this.title
      text: this.text
  .then (response) ->
    Ember.run () ->
      Blorgh.Post.create(response)
```

Depending on whether or not the object being saved, the `update` or `create` functions will be called.

If we refresh the page again and edit the post title, we'll see that it's updating live at the top of the page. This is because the `{{title}}` within the `edit` template is bound to the same `title` value within the form. Updating one will automatically update the other.

If we change the title of the post and hit "Save", we should now see the new title.

![Ember Post Update](/ember/ember_post_update.png)

Now we've completed adding the `edit` and `update` functionality to our posts resource. All that's left to do is to add a `destroy` and then we've completed all the actions for this resource. To destroy a post will not require a view, and therefore rather than using a `link-to` like we would in Rails, we can use an `action` in the `post` template instead. Let's open `app/assets/javascripts/templates/post.hbs` and add a link to destroy a post:

```hbs
<h2>{{title}}</h2>
<div>
  {{#link-to 'posts.edit' this}}Edit{{/link-to}} |
  <a {{action='destroy'}}>Destroy</a>
</div>
{{text}}
```

We will need to implement this action on the controller instead of the route for this template, which would be `Blorgh.PostController`, which we will need to define in `app/assets/javascripts/controllers/post.js.coffee`:

```coffee
Blorgh.PostController = Ember.ObjectController.extend
  actions:
    destroy: ->
      if confirm('Are you sure you want to delete this post?')
        this.content.destroy()
```

In the controller, we can reference the current model instance with `this.content` rather than `this.currentModel`. We first ask for confirmation of the deletion of this post and if it's confirmed then we call `destroy` on it which should trigger the destruction of this post.

Let's implement the `destroy` function in `app/javascripts/models/post.js.coffee` like this:

```coffee
  destroy: ->
    $.ajax "api/posts/#{@id}",
      type: 'DELETE'
```

When we refresh the post's page, we should see the 'destroy' link now. When we click it, we'll be asked if we are sure if we want to delete this post. If we click "OK", then the post will be deleted and we'll be sent back home.

## Ember Data

Now that we have all of these actions in place, our `Blorgh.Post` model has become the largest piece of code in our Ember app. We wrote all that code ourselves so that we could learn how all the pieces of Ember fit together. Designing models like we have is not the best practice in the Ember community. The best practice is to use another piece of Ember called Ember Data.

Ember Data provides some adapters and serializers that make working with APIs easier. Without Ember Data, we would need to write the same old boilerplate code for our models and that would be no fun, so let's go ahead now and replace the code in our model with something more conventional.

To begin with, we're going to need to add a require for `ember-data` to our `app/assets/javascripts/application.js.coffee` line, directly under the require for `ember`:

```coffee
#= require jquery
#= require jquery_ujs
#= require handlebars
#= require ember
#= require ember-data
#= require_self
#= require blorgh
```

For Ember Data to work properly, our Ember application needs an adapter so that it can talk with our API. We can define one of these now in a new file called `app/assets/javascripts/store.js.coffee`:

```coffee
  Backend.ApplicationAdapter = DS.ActiveModelAdapter.extend
    namespace: 'api'
```

We're extending from `ActiveModelAdapter` here because our API closely matches the API expected by Ember's `ActiveModelAdapter`. It doesn't *quite* match -- as we'll see a little later -- but it's close enough. Inside this new adapter we define a `namespace` which Ember will scope all requests to, so instead of looking for posts at `/posts`, it will look for them at `/api/posts` instead.

To begin using this adapter, let's delete the `app/assets/javascripts/models/post.js.coffee` file's content and start anew.

```coffee
Blorgh.Post = DS.Model.extend
  title: DS.attr('string')
  text: DS.attr('string')
```

To define a model that uses `Blorgh.ApplicationAdapter`, all we need to do is extend `DS.Model` and define the attributes that we care about, in this case `title` and `text` are all we care about in a post so far. We define them like this so that Ember Data loads them from the result.

Let's see if this is working by making a new request to the root of our application. We should see all the posts that we've got. 

![Ember Posts](/ember/ember_posts.png)

Clicking on a post's title should still take you to that post's page. 

![Ember Post](/ember/ember_post.png)

That's a good start. Ember data is working just fine, or so we think. If we refresh this page, we'll come up against our first Ember Data incompatibility, which we'll see in the JavaScript console:

```
Error while loading route: Error: No model was found for 'id'
```

The code is claiming that it cannot find a model for `id`, but nowhere are we asking it to do that. What's actually happening is that Ember is inferring the model name from the first parameter which is sent back in the response from `/api/posts/:id`, which just so happens to be `id`. 

We need to give Ember the correct format of our data, and the way to do that is to create a new serializer. Serializers in Ember Data can be used to modify the response coming back from the server and massage it into an appropriate format. Let's define this new serializer in `app/assets/javascripts/store.js.coffee`:

```coffee
Blorgh.ApplicationSerializer = DS.ActiveModelSerializer.extend
  # Turns { id: 1, ... } into something like { post: { id: 1, ... } }
  extractSingle: (store, type, oldPayload) ->
    newPayload = {}
    newPayload[type.typeKey] = oldPayload

    this._super(store, type, newPayload)
```

In order to massage the post response that's coming back from `/api/posts/:id`, we need to define an `extractSingle` method on `Blorgh.ApplicationSerializer`. This method takes the Ember Data store object, the type of object we're loading, and the payload which represents the response from the API. `type.typeKey` here will return `post`, and so `newPayload` will be something like `{ post: { id: 1, ... } }`, which will make Ember happy. We call `this._super` at the end of this method in order to call the original `extractSingle` method which is defined within `DS.ActiveModelSerializer`.

When we refresh the post page again, we should be able to see the post we want. As an added bonus of this, our editing of that post will work also. Go on, give it a go!

The 'Destroy' link is a whole other story. When we attempt to delete a post, we'll see this error:

```
Error while loading route: TypeError: Cannot read property 'pushedData' of null
```

The trace of this error isn't that helpful, so let's track down what's happening here by walking through it. It all starts with the destroy action within `app/assets/javascripts/templates/post.hbs`:

```hbs
<h2>{{title}}</h2>
<div>
  {{#link-to 'posts.edit' this}}Edit{{/link-to}}
  <a {{action 'destroy'}}>Destroy</a>
</div>
{{text}}
```

This action is handled by `Blorgh.PostController`:

```coffee
Blorgh.PostController = Ember.ObjectController.extend
  actions:
    destroy: ->
      if confirm('Are you sure you want to delete this post?')
        this.content.destroy()
        this.transitionTo('index')
```

The `destroy` method that we're calling here... how can we be sure if that's the right method? Well, we can't be sure unless we check [the documentation](http://emberjs.com/guides/models/creating-and-deleting-records/#toc_deleting-records), which says that we should call `.deleteRecord` and then `save` to actually delete a record. So let's change this controller now:

```coffee
Blorgh.PostController = Ember.ObjectController.extend
  actions:
    destroy: ->
      if confirm('Are you sure you want to delete this post?')
        this.content.deleteRecord()
        this.content.save()
        this.transitionTo('index')
```

Let's refresh the page and try deleting that post again. It will now disappear, as it should!

We've now got `index`, `show`, `edit`, `update` and `destroy` covered. All that's left to make sure still works is the `new` and `create` actions. Let's go back to the root of the blog and try to create a new post now. That whole process should work.

## Retrospective #2: Ember Data

As we can see here, Ember Data makes it exceptionally simple to interact with an API to create, read, update and destroy records. There's no need yet for us to write our own code to interact with the API; all the standard actions have been taken care of.

## Creating Comments

Now what's a blog post without the ability to write comments on it? Comments are where the great thinkers and thought leaders of the world share their thoughts and opinions, moving society forward at a pace faster than the world has ever seen before.


TODO: Add comments to posts
